// Active loans and returns management

async function loadReturnWindow() {
  const container = document.getElementById("loansContainer");
  if (!container) return;

  container.innerHTML = '<div class="empty-state"><p>Loading...</p></div>';

  // Try to fetch from backend API
  let activeLoans = [];
  let lastErrorBody = null;
  try {
    // Build candidate URLs using configured API base so production/local resolve reliably
    const urls = [
      window.PHYLAB_API && typeof window.PHYLAB_API === "function"
        ? window.PHYLAB_API("/api/borrow-requests/?status=borrowed")
        : "/api/borrow-requests/?status=borrowed",
      "/api/borrow-requests/?status=borrowed",
      // fallback to custom action if present
      window.PHYLAB_API && typeof window.PHYLAB_API === "function"
        ? window.PHYLAB_API("/api/borrow-requests/currently_borrowed/")
        : "/api/borrow-requests/currently_borrowed/",
      "/api/borrow-requests/currently_borrowed/",
    ];

    let response = null;
    // Prepare auth-aware fetch options
    const token = sessionStorage.getItem("auth_token");
    for (const url of urls) {
      try {
        const options = { method: "GET", mode: "cors" };
        if (token) options.headers = { Authorization: "Token " + token };
        else options.credentials = "include";

        response = await fetch(url, options);
        async function completeReturn(requestId, itemId) {
          // Directly open the date-picker modal so admin can confirm or edit timestamp
          try {
            let resolvedReqId = requestId;
            try {
              if (typeof resolveRequestNumericId === 'function') {
                resolvedReqId = await resolveRequestNumericId(requestId);
              }
            } catch (e) {
              console.warn('resolveRequestNumericId failed', e);
            }
            openReturnDateModal(resolvedReqId, itemId);
          } catch (e) {
            console.error('completeReturn: failed to open return modal', e);
          }
        }
      if (itemIndex !== -1) {
        let itemToArchive = queue[itemIndex];

        if (itemToArchive.items && itemToArchive.items.length > 0) {
          const itemData = itemToArchive.items[0];
          const stockKey = "stock_" + (itemData.itemKey || itemData.name);

          const qtyToReturn = parseInt(itemData.quantity) || 1;

          let currentStock = parseInt(localStorage.getItem(stockKey)) || 0;
          localStorage.setItem(stockKey, currentStock + qtyToReturn);
          console.log(
            "completeReturn: restored stock for",
            stockKey,
            "new total:",
            currentStock + qtyToReturn,
          );
        }

        itemToArchive.actualReturnDate = new Date().toLocaleString();
        itemToArchive.status = "returned";

        history.push(itemToArchive);
        queue.splice(itemIndex, 1);

        localStorage.setItem("phyLab_History", JSON.stringify(history));
        localStorage.setItem("phyLab_RequestQueue", JSON.stringify(queue));
        console.log("completeReturn: updated localStorage, moved to history");
      } else if (backendSuccess && backendResponse) {
        console.log(
          "completeReturn: no local queue entry, creating from backend response",
        );
        // Backend succeeded but we have no local queue entry. Create a minimal
        // archive entry from the backend response (if available) so the
        // dashboard history / frequent-items chart can include this return.
        try {
          const orig =
            backendResponse.original_request || backendResponse || null;
          const archiveEntry = {
            id: (orig && (orig.id || orig.request_id)) || requestId,
            request_id:
              (orig && (orig.request_id || orig.requestId)) || requestId,
            studentName:
              (orig && (orig.student_name || orig.studentName)) || "",
            student_id: (orig && (orig.student_id || orig.studentId)) || "",
            email: (orig && orig.email) || "",
            teacher_name: (orig && orig.teacher_name) || "",
            borrow_date: (orig && orig.borrow_date) || "",
            return_date: (orig && orig.return_date) || "",
            status: "returned",
            actualReturnDate: new Date().toLocaleString(),
            items: [],
          };

          if (orig && Array.isArray(orig.items)) {
            const returnedItem = orig.items.find(
              (it) => String(it.id) === String(itemId),
            );
            if (returnedItem) {
              const itemObj = {
                id: returnedItem.id,
                name: returnedItem.item_name || returnedItem.name || "",
                itemKey: returnedItem.item_key || returnedItem.itemKey || "",
                quantity: returnedItem.quantity || 1,
                item_image: returnedItem.item_image || returnedItem.image || "",
                status: returnedItem.status || "returned",
              };
              archiveEntry.items.push(itemObj);

              // restore stock in localStorage
              const stockKey = "stock_" + (itemObj.itemKey || itemObj.name);
              const qtyToReturn = parseInt(itemObj.quantity) || 1;
              let currentStock = parseInt(localStorage.getItem(stockKey)) || 0;
              localStorage.setItem(stockKey, currentStock + qtyToReturn);
              console.log(
                "completeReturn: restored stock from backend data for",
                stockKey,
              );
            }
          }

          history.push(archiveEntry);
          localStorage.setItem("phyLab_History", JSON.stringify(history));
          console.log(
            "completeReturn: created archive entry from backend data",
          );
        } catch (e) {
          console.warn(
            "completeReturn: failed to archive returned item from backend payload",
            e,
          );
        }
      }

      if (backendSuccess) {
        showNotification(
          "Item returned successfully! Now visible in History page.",
          "success",
        );
      } else {
        showNotification(
          "Item marked as returned locally. Backend update failed.",
          "warning",
        );
      }

      // Reload the active loans page to remove the returned item
      console.log("completeReturn: reloading active loans display");
      loadReturnWindow();
      if (typeof loadStockFromMemory === "function") loadStockFromMemory();
      if (typeof loadDashboardStats === "function") loadDashboardStats();
      if (typeof initLiveChart === "function") initLiveChart();

      console.log("completeReturn: complete!");
    },
  );
}

// ---------- Return Date modal helpers ----------
let __pendingReturnReqId = null;
let __pendingReturnItemId = null;

function formatForDatetimeLocal(d) {
  // format a Date into yyyy-MM-ddTHH:mm for input[type=datetime-local]
  const pad = (n) => String(n).padStart(2, '0');
  return (
    d.getFullYear() + '-' +
    pad(d.getMonth() + 1) + '-' +
    pad(d.getDate()) + 'T' +
    pad(d.getHours()) + ':' +
    pad(d.getMinutes())
  );
}

function openReturnDateModal(resolvedReqId, itemId) {
  __pendingReturnReqId = resolvedReqId;
  __pendingReturnItemId = itemId;
  const modal = document.getElementById('returnDateModal');
  const input = document.getElementById('returnDateInput');
  if (input) {
    input.value = formatForDatetimeLocal(new Date());
  }
  if (modal) modal.style.display = 'flex';
}

function closeReturnDateModal() {
  const modal = document.getElementById('returnDateModal');
  if (modal) modal.style.display = 'none';
  __pendingReturnReqId = null;
  __pendingReturnItemId = null;
}

async function performReturnPatch(resolvedReqId, itemId, actualReturnedAtIso) {
  const urls = [
    window.PHYLAB_API && typeof window.PHYLAB_API === 'function'
      ? window.PHYLAB_API(`/api/borrow-requests/${resolvedReqId}/update_item_statuses/`)
      : `/api/borrow-requests/${resolvedReqId}/update_item_statuses/`,
    `/api/borrow-requests/${resolvedReqId}/update_item_statuses/`,
  ];

  const payload = {
    items: actualReturnedAtIso
      ? [{ id: itemId, status: 'returned', actual_returned_at: actualReturnedAtIso }]
      : [{ id: itemId, status: 'returned' }],
  };

  let response = null;
  const token = sessionStorage.getItem('auth_token');
  for (const url of urls) {
    try {
      const options = {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
        mode: 'cors',
      };
      if (token) options.headers.Authorization = 'Token ' + token;
      else options.credentials = 'include';

      response = await fetch(url, options);
      if (response && response.ok) {
        try {
          const json = await response.json();
          return { backendSuccess: true, backendResponse: json };
        } catch (e) {
          return { backendSuccess: true, backendResponse: null };
        }
      }
    } catch (e) {
      continue;
    }
  }
  return { backendSuccess: false, backendResponse: null };
}

function finalizeReturn(backendSuccess, backendResponse, requestId, itemId) {
  // The original localStorage/archive logic moved here
  let queue = JSON.parse(localStorage.getItem('phyLab_RequestQueue')) || [];
  let history = JSON.parse(localStorage.getItem('phyLab_History')) || [];

  const itemIndex = queue.findIndex((req) => String(req.id) === String(requestId));

  if (itemIndex !== -1) {
    let itemToArchive = queue[itemIndex];

    if (itemToArchive.items && itemToArchive.items.length > 0) {
      const itemData = itemToArchive.items[0];
      const stockKey = 'stock_' + (itemData.itemKey || itemData.name);

      const qtyToReturn = parseInt(itemData.quantity) || 1;

      let currentStock = parseInt(localStorage.getItem(stockKey)) || 0;
      localStorage.setItem(stockKey, currentStock + qtyToReturn);
    }

    itemToArchive.actualReturnDate = new Date().toLocaleString();
    itemToArchive.status = 'returned';

    history.push(itemToArchive);
    queue.splice(itemIndex, 1);

    localStorage.setItem('phyLab_History', JSON.stringify(history));
    localStorage.setItem('phyLab_RequestQueue', JSON.stringify(queue));
  } else if (backendSuccess && backendResponse) {
    try {
      const orig = backendResponse.original_request || backendResponse || null;
      const archiveEntry = {
        id: (orig && (orig.id || orig.request_id)) || requestId,
        request_id: (orig && (orig.request_id || orig.requestId)) || requestId,
        studentName: (orig && (orig.student_name || orig.studentName)) || '',
        student_id: (orig && (orig.student_id || orig.studentId)) || '',
        email: (orig && orig.email) || '',
        teacher_name: (orig && orig.teacher_name) || '',
        borrow_date: (orig && orig.borrow_date) || '',
        return_date: (orig && orig.return_date) || '',
        status: 'returned',
        actualReturnDate: new Date().toLocaleString(),
        items: [],
      };

      if (orig && Array.isArray(orig.items)) {
        const returnedItem = orig.items.find((it) => String(it.id) === String(itemId));
        if (returnedItem) {
          const itemObj = {
            id: returnedItem.id,
            name: returnedItem.item_name || returnedItem.name || '',
            itemKey: returnedItem.item_key || returnedItem.itemKey || '',
            quantity: returnedItem.quantity || 1,
            item_image: returnedItem.item_image || returnedItem.image || '',
            status: returnedItem.status || 'returned',
          };
          archiveEntry.items.push(itemObj);

          const stockKey = 'stock_' + (itemObj.itemKey || itemObj.name);
          const qtyToReturn = parseInt(itemObj.quantity) || 1;
          let currentStock = parseInt(localStorage.getItem(stockKey)) || 0;
          localStorage.setItem(stockKey, currentStock + qtyToReturn);
        }
      }

      history.push(archiveEntry);
      localStorage.setItem('phyLab_History', JSON.stringify(history));
    } catch (e) {
      console.warn('finalizeReturn: failed to archive returned item from backend payload', e);
    }
  }

  if (backendSuccess) {
    showNotification('Item returned successfully! Now visible in History page.', 'success');
  } else {
    showNotification('Item marked as returned locally. Backend update failed.', 'warning');
  }

  // Reload UI
  loadReturnWindow();
  if (typeof loadStockFromMemory === 'function') loadStockFromMemory();
  if (typeof loadDashboardStats === 'function') loadDashboardStats();
  if (typeof initLiveChart === 'function') initLiveChart();
}

// Hook the modal confirm button
document.addEventListener('DOMContentLoaded', function () {
  const btn = document.getElementById('confirmReturnDateBtn');
  if (!btn) return;
  btn.onclick = async function () {
    const input = document.getElementById('returnDateInput');
    let val = input ? input.value : null;
    let actualIso = null;
    if (val) {
      try {
        // convert local datetime-local value to ISO (UTC)
        actualIso = new Date(val).toISOString();
      } catch (e) {
        actualIso = null;
      }
    }

    const reqId = __pendingReturnReqId;
    const itemId = __pendingReturnItemId;
    closeReturnDateModal();
    if (!reqId || !itemId) return;

    const result = await performReturnPatch(reqId, itemId, actualIso);
    finalizeReturn(result.backendSuccess, result.backendResponse, String(reqId), String(itemId));
  };
});

async function openBorrowingDetails(requestId) {
  // Try to fetch from backend API first
  let request = null;

  try {
    const urls = [
      window.PHYLAB_API && typeof window.PHYLAB_API === "function"
        ? window.PHYLAB_API(`/api/borrow-requests/${requestId}/`)
        : `/api/borrow-requests/${requestId}/`,
      `/api/borrow-requests/${requestId}/`,
    ];

    let response = null;
    const token = sessionStorage.getItem("auth_token");
    for (const url of urls) {
      try {
        const options = { method: "GET", mode: "cors" };
        if (token) options.headers = { Authorization: "Token " + token };
        else options.credentials = "include";

        response = await fetch(url, options);
        if (response.ok) break;
      } catch (e) {
        continue;
      }
    }

    if (response && response.ok) {
      const data = await response.json();
      // Normalize backend response — map common server field names to frontend view model
      request = {
        id: data.id,
        requestId: data.request_id || data.requestId || data.id,
        studentName:
          data.student_name ||
          data.studentName ||
          data.full_name ||
          data.fullname ||
          "",
        studentID: data.student_id || data.studentId || data.id_number || "",
        email: data.email || data.student_email || "",
        studentPhone:
          data.student_phone ||
          data.phone ||
          data.contact ||
          data.student_phone_number ||
          "",
        studentDepartment: data.department || data.student_department || "",
        teacherName: data.teacher_name || data.teacherName || "",
        teacherEmail: data.teacher_email || data.teacher_email_address || "",
        teacherPhone: data.teacher_phone || data.teacher_phone_number || "",
        purpose: data.purpose || data.reason || "",
        borrowDate: data.borrow_date || data.borrowDate || "",
        returnDate: data.return_date || data.returnDate || "",
        status: data.status || "",
        adminRemark: data.admin_remark
          ? {
              type: data.remark_type || data.admin_remark_type || "",
              text: data.admin_remark,
              createdAt:
                data.remark_created_at || data.admin_remark_created_at || null,
            }
          : null,
        items: (data.items || []).map((item) => ({
          id: item.id,
          name: item.item_name || item.name || "",
          itemKey: item.item_key || item.itemKey || "",
          quantity: item.quantity || 1,
          image: item.item_image || item.image || "",
          description:
            item.description || item.item_description || item.item_desc || "",
          status: item.status || "pending",
          admin_remark: item.admin_remark || item.remark || "",
          remark_type: item.remark_type || null,
          remark_created_at: item.remark_created_at || null,
        })),
      };
    }
  } catch (error) {
    console.error("Error fetching request details from backend:", error);
  }

  // Fallback to localStorage if backend fetch failed
  if (!request) {
    const allRequests =
      JSON.parse(localStorage.getItem("phyLab_RequestQueue")) || [];
    const history = JSON.parse(localStorage.getItem("phyLab_History")) || [];
    request = [...allRequests, ...history].find(
      (r) => String(r.id) === String(requestId),
    );
  }

  if (!request) {
    showNotification("Details not found.", "error");
    return;
  }

  const item =
    request.items && request.items.length > 0 ? request.items[0] : {};

  document.getElementById("det-item-name").innerText = item.name || "N/A";
  document.getElementById("det-item-img").src = item.image || "default.png";
  document.getElementById("det-description").innerText =
    item.description || "Physics Lab Equipment";
  document.getElementById("det-inv-id").innerText =
    request.id || request.requestId || "N/A";
  const headerReqEl = document.getElementById("det-request-id-header");
  if (headerReqEl)
    headerReqEl.innerText = request.requestId || request.id || "—";
  document.getElementById("det-condition").innerText = "Good";

  document.getElementById("det-borrower-name").innerText =
    request.studentName || "N/A";
  document.getElementById("det-borrower-id").innerText =
    "ID: " +
    (request.studentID || request.studentId || request.student_id || "N/A");
  document.getElementById("det-email").innerText = request.email || "N/A";
  const requestIdEl = document.getElementById("det-request-id");
  if (requestIdEl)
    requestIdEl.innerText = request.requestId || request.id || "N/A";

  document.getElementById("det-teacher").innerText =
    request.teacherName || "N/A";

  document.getElementById("det-borrow-date").innerText =
    request.borrowDate || "N/A";
  document.getElementById("det-return-date").innerText =
    request.returnDate || "N/A";
  document.getElementById("det-purpose").innerText =
    request.purpose || "No purpose stated.";

  const statusEl = document.getElementById("det-status");
  const currentStatus = (request.status || "borrowed").toString().toLowerCase();
  statusEl.innerText = currentStatus.toUpperCase();
  statusEl.className = `status-tag status-${currentStatus}`;

  // Show admin remark if exists — use backend data only
  let remark = null;
  if (item.admin_remark) {
    remark = {
      type: item.remark_type || "",
      text: item.admin_remark,
      createdAt: item.remark_created_at || null,
    };
  } else if (request.adminRemark) {
    remark = request.adminRemark;
  }
  const remarkSection = document.getElementById("det-remark-section");

  if (remark && (remark.type || remark.text)) {
    remarkSection.style.display = "block";
    document.getElementById("det-remark-type").textContent =
      getRemarkTypeLabel(remark.type) || "";
    document.getElementById("det-remark-text").textContent =
      remark.text || "No description provided.";

    const remarkDate = remark.createdAt
      ? new Date(remark.createdAt).toLocaleString()
      : "";
    document.getElementById("det-remark-meta").textContent = remarkDate
      ? `Added: ${remarkDate}`
      : "";
  } else {
    remarkSection.style.display = "none";
  }

  document.getElementById("Borrowing-Details-window").style.display = "flex";
}

// Expose to global scope so it can be called from admin-history.js
window.openBorrowingDetails = openBorrowingDetails;

// Send reminder email handler
function initSendReminderHandler() {
  const btn = document.getElementById("sendReminderBtn");
  if (!btn) return;

  btn.onclick = function () {
    const borrowerEmail = document.getElementById("det-email").innerText;

    if (borrowerEmail === "---" || !borrowerEmail.includes("@")) {
      showNotification("No valid email address found.", "error");
      return;
    }

    this.innerText = "Sending...";
    this.disabled = true;

    const itemName = document.getElementById("det-item-name").innerText;
    const borrowerName = document.getElementById("det-borrower-name").innerText;
    const returnDate = document.getElementById("det-return-date").innerText;

    const templateParams = {
      subject: `Reminder: Return ${itemName}`,
      to_email: borrowerEmail,
      to_name: borrowerName,
      student_name: borrowerName,
      status: "",
      item_details: "",
      item_name: itemName,
      return_date: returnDate,
      message_html: `<p>Hi ${borrowerName},</p>
        <p>This is a friendly reminder to return <strong>${itemName}</strong> by <strong>${returnDate}</strong>.</p>
        <p>Please contact us if you need an extension.</p>
        <p>Thanks,<br/>PhyLab Team</p>`,
      logo_url: `${window.location.origin}/Phylab.png`,
      company_url: window.location.origin,
      company_email: "support@" + window.location.hostname,
    };

    safeSendEmail(EMAILJS_SERVICE_ID, EMAILJS_SHARED_TEMPLATE, templateParams)
      .then(() => {
        this.innerText = "Send Reminder";
        this.disabled = false;
        showNotification("Reminder sent successfully!", "success");
      })
      .catch((err) => {
        console.error("EmailJS send error", err);
        this.innerText = "Send Reminder";
        this.disabled = false;
        showNotification("Failed to send reminder.", "error");
      });
  };
}

// Initialize on DOM ready
document.addEventListener("DOMContentLoaded", initSendReminderHandler);

// Event delegation for return buttons to ensure handler works even if
// inline onclick handlers fail (e.g. non-global function scope).
document.addEventListener("click", function (e) {
  const btn = e.target.closest && e.target.closest(".return-btn");
  if (!btn) return;
  const requestId = btn.getAttribute("data-request-id");
  const itemId = btn.getAttribute("data-item-id");
  if (requestId && itemId) {
    completeReturn(requestId, itemId);
  }
});
